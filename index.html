<textarea name="text" cols="25" rows="5">
    1a.

%{
#include<stdio.h>
int v=0,op=0,id=0,flag=0;
%}

%%
[a-zA-Z]+[0-9a-zA-Z]*  {id++;}
[0-9]+  {id++;}
[\+\-\*/\=]  {op++;}
"("  {v++;}
")"  {v--;}
";" {flag=1;}
.|\n {return 0;}
%%

int main()
{
printf("enter the expression:");
yylex();
if((op+1)==id && v==0  && flag==0)
{
printf("\nexpression is valid\n");
printf("no of identifier=%d\n no of operators=%d\n",id,op);
}
else
printf("\nexpression is invalid\n");
return 0;
}
int yywrap()
{
return 1;
}


1b.
lex part

%option noyywrap
%{
#include "y.tab.h"
extern int yylval;
%}

%%
[0-9]+    {yylval=atoi(yytext);return num;}
[\+\-\*\/]  {return yytext[0];}
[)]         {return yytext[0];}
[(]         {return yytext[0];}
.           {;}
\n          {return 0;}
%%

yacc part
%{
#include<stdio.h>
#include<stdlib.h>
int yyerror();
int yylex();
%}

%token num
%left '+''-'
%left'*''/'

%%
input:exp {printf("%d\n",$$);exit(0);}
exp:  exp'+'exp {$$=$1+$3;}
     |exp'-'exp {$$=$1-$3;}
     |exp'*'exp {$$=$1*$3;}
     |exp'/'exp {if($3==0){printf("divide by zero.invalid expression.\n");exit(0);}
     else $$=$1/$3;}
     |'('exp')'{$$=$2;}
     |num{$$=$1;};
%%
int yyerror()
{
printf("error:invalid expression.\n");
exit(0);
}
int main()
{
printf("enter an expression:\n");
yyparse();
}

2.
lex part:

%option noyywrap
%{
#include "y.tab.h"
%}
%%
a {return A;}
b {return B;}
[\n] return '\n';
%%

YACC Part
%{
#include<stdio.h>
#include<stdlib.h>
int yyerror();
int yylex();
%}
%token A B
%%
input:s'\n' {printf("Successful Grammar\n");exit(0);}
s: A s1 B| B 
s1: ; | A s1
%%
int main()
{
printf("Enter A String\n"); 
yyparse();
return 0;
}
int yyerror()
{
printf("Error \n"); 
exit(0);
}

3.
   
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
char prod[3][10]={"A->aBa","B->bB","B->@"},input[10],stack[25];
int top=-1;int j=0,k,l;
void push(char item)
{
stack[++top]=item;
}
void pop()
{
top=top-1;
}
void display()
{
int j;
for(j=top;j>=0;j--)
printf("%c",stack[j]);
}
void stackpush(char p)
{
if(p=='A')
{
pop();
for(j=strlen(prod[0])-1;j>=3;j--)
push(prod[0][j]);
}
else
{
pop();
for(j=strlen(prod[1])-1;j>=3;j--)
push(prod[1][j]);
}
}
void main()
{
char c; int i;
printf("first(A)={a}\t");
printf("follow(A)={$}\n");
printf("first(B)={b,@}\t");
printf("follow(B)={a}\n\n");
printf("\t a \t b \t $ \n");
printf("A\t%s\n",prod[0]);
printf("B\t%s\t%s\n",prod[2],prod[1]);
printf("enter the input string terminated with $ to parse:-");
scanf("%s",input);
for(i=0;input[i]!='\0';i++)
{
if((input[i]!='a')&&(input[i]!='b')&&(input[i]!='$'))
{
printf("invalid string");
exit(0);
}
}
if(input[i-1]!='$')
{
printf("\n\nInput string entered without end marker $");
exit(0);
}
push('$');
push('A');
i=0;
printf("\n\n");
printf("stack\tinput\taction");
printf("\n------------\n");
while(i!=strlen(input)&&stack[top]!='$')
{
printf("\n");
for(l=top;l>=0;l--)
printf("%c",stack[l]);
printf("\t");
if(stack[top]=='A')
{
printf("A->aBa");
stackpush('A');
}
else if(stack[top]=='B')
{
if(input[i]!='b')
{
printf("B->@");
printf("\t matched @");
pop();
}
else
{
printf("B->bB");
stackpush('B');
}
}
else
{
if(stack[top]==input[i])
{
printf("pop%c",input[i]);
printf("\t matched %c",input[i]);
pop();
i++;
}
else
break;
 }
 }
 if(stack[top]=='$' && input[i]=='$')
 {
 printf("\n$\t$");
 printf("\n valid string accepted\n");
 }
 else
 printf("\n invalid string rejected\n");
}


4.
  
  #include<stdio.h>
#include<string.h>
int k=0,z=0,i=0,j=0,c=0;
char a[16],ac[20],stk[15],act[10];
void check();
void main()
{
	printf("Grammar: \n E->E+T|T \n T->T*F|F \n F->(E)|id\n");
	printf("Enter the input string\n");
	scanf("%s",a);
	c=strlen(a);
	strcpy(act,"SHIFT->");
	printf("Stack \t Input \t\t Action\n");
	printf("$\t %s$",a); //Initial contents of the input buffer
	for(k=0,i=0;j<c;k++,i++,j++)
	{
		if(a[j]=='i' && a[j+1]=='d')
		{
			stk[i]=a[j];
			stk[i+1]=a[j+1];
			stk[i+2]='\0';
			a[j]=' ';
			a[j+1]=' ';
			printf("\n$%s\t%s$\t%s id",stk,a,act);
			check();
		}
		else
		{
			stk[i]=a[j];
			stk[i+1]='\0';
			a[j]=' ';
			printf("\n$%s\t%s$\t%s symbol",stk,a,act);
			check();
		}
	}printf("\n");
	getchar();
}

void check()
{
	strcpy(ac,"REDUCE");
	for(z=0;z<c;z++)
		if(stk[z]=='(' && stk[z+1]=='E'&& stk[z+2]==')')
		{
			stk[z]='F';
			stk[z+1]='\0';
			stk[z+2]='\0';
			printf("\n$%s\t%s$\t%s by F->(E)",stk,a,ac);
			i=i-2;
		}
	for(z=0;z<c;z++)
		if(stk[z]=='i' && stk[z+1]=='d')
		{
			stk[z]='F';
			stk[z+1]='\0';
			printf("\n$%s\t%s$\t%s by F->id",stk,a,ac);
			j++;
		}
	for(z=0;z<c;z++)
	{
		if(stk[z]=='T' && stk[z+1]=='*' && stk[z+2]=='F')
		{
			stk[z]='T';
			stk[z+1]='\0';
			stk[z+2]='\0';
			printf("\n$%s\t%s$\t%s by T->T*F",stk,a,ac);
			i=i-2;
		}
		else if(stk[z]=='F')
		{
			stk[z]='T';
			printf("\n$%s\t%s$\t%s by T->F",stk,a,ac);
		}
	}
	for(z=0;z<c;z++)
	{
		if(stk[z]=='E' && stk[z+1]=='+' && stk[z+2]=='T' && stk[z+3]=='*')
			break;
		if(stk[z]=='E' && stk[z+1]=='+' && stk[z+2]=='T')
			if(a[j+1]=='*')
				break;
			else
			{
				stk[z]='E';
				stk[z+1]='\0';
				stk[z+2]='\0';
				printf("\n$%s\t%s$\t%s by E->E+T",stk,a,ac);
				i=i-2;
			}
			else if(stk[z]=='T')
			{
                if(stk[z+1]=='*' || a[j+1]=='*')
                        break;
				stk[z]='E';
				printf("\n$%s\t%s$\t%s by E->T",stk,a,ac);
			}
		}
}


5.

 #include<stdio.h>
#include<stdlib.h>
#include<string.h>
char op[2],arg1[5],arg2[5],result[5];
int count=0;
void main()
{
	FILE *fp1,*fp2;
	fp1=fopen("input.txt","r");
	fp2=fopen("output.txt","w");
	while(!feof(fp1) && count<4)
	{
		count ++;
		fscanf(fp1,"%s%s%s%s",result,arg1,op,arg2);
		if(strcmp(op,"+")==0)
		{
			fprintf(fp2,"\nMOV R0,%s",arg1);
			fprintf(fp2,"\nADD R0,%s",arg2);
			fprintf(fp2,"\nMOV %s,R0",result);
		}
		if(strcmp(op,"*")==0)
		{	
			fprintf(fp2,"\nMOV R0,%s",arg1);
			fprintf(fp2,"\nMUL R0,%s",arg2);
			fprintf(fp2,"\nMOV %s,R0",result);
		}		
		if(strcmp(op,"-")==0)
		{
			fprintf(fp2,"\nMOV R0,%s",arg1);
			fprintf(fp2,"\nSUB R0,%s",arg2);
			fprintf(fp2,"\nMOV %s,R0",result);
		}
		if(strcmp(op,"/")==0)
		{
			fprintf(fp2,"\nMOV R0,%s",arg1);
			fprintf(fp2,"\nDIV R0,%s",arg2);
			fprintf(fp2,"\nMOV %s,R0",result);
		}
		if(strcmp(op,"=")==0)
		{
			fprintf(fp2,"\nMOV R0,%s",arg1);
			fprintf(fp2,"\nMOV %s,R0",result);
		}
	}
	fclose(fp1);
	fclose(fp2);
}

6a.
%{
#include<stdio.h>
#include<stdlib.h>
%}

%%
"/*"[a-zA-Z0-9' '\t\n]+"*/" {}
"//".* {}
%%

int main()
{
 yyin=fopen("input.c","r");
 yyout=fopen("out.c","w");
 yylex();
 fclose(yyin);
 fclose(yyout);
 return 0;
}
int yywrap()
{
}

6b.
lex part:

%{
#include <stdio.h>
#include "y.tab.h"
extern yylval;
%}
%%
[ \t] ;
[+|-|*|/|=|<|>] {printf("operator is %s\n",yytext);return OP;}
[0-9]+ {yylval = atoi(yytext); printf("numbers is %d\n",yylval); return DIGIT;} 
int|char|bool|float|void|for|do|while|if|else|return|void {printf("keyword is 
%s\n",yytext);return KEY;}
[a-zA-Z0-9]+ {printf("identifier is %s\n",yytext);return ID;}
. ;
%%
Yacc File
 
%{
 #include<stdio.h>
 #include<stdlib.h>
 int id=0,dig=0,key=0,op=0;
%}
%token DIG ID KEY OP

%%
input:
 DIG input{dig++;}
|ID input{id++;}
|KEY input{key++;}
|OP input{op++;}
|DIG {dig++;}
|ID {id++;}
|KEY {key++;}
|OP {op++;} ;
%%

extern int yylex();
extern int yyparse();
extern FILE *yyin;
int main()
{
 FILE *fp=fopen("eg.c","r");
 if(!fp)
 {
  printf("File not found\n");
  return -1;
 }
 yyin=fp;
 do{
    yyparse();
 }while(!feof(yyin));
 printf("Numbers = %d\n Operators = %d\n Identifiers = %d\n Keywords = %d\n",dig,op,id,key);
}

int yyerror()
{
 printf("Error \n");
 exit(-1);
}
int yywrap()
{ }

7.

  #include<stdio.h>
int main()
{
int count,j,n,time, flag=0, time_quantum,ch=0;
int wait_time=0, turnaround_time=0,at[10], bt [10], rt[10];

int endTime, i, smallest;
int remain=0, sum_wait=0 ,sum_turnaround=0;
printf("1. Round Robin \n2. SRTF \n");
scanf("%d", &ch); 
printf("Enter no of Processes:" );
scanf("%d", &n);
for (i=0;i<n;i++)
{
printf("Enter arrival time for process P%d : ",i+1);
scanf("%d", &at[i]); 
printf("Enter burst time for Process P%d ",i+1);
scanf("%d", &bt[i]);
rt[i]=bt[i];
}
switch(ch)
{
case 1:
printf("Enter Time Quantum:\t"); 
scanf("%d", &time_quantum);
remain=n;
printf("\nProcess time | Turnaround Time | Waiting Time\n");
for (time=0;count=0; remain!=0);
{
if(rt[count] <=time_quantum && rt[count]>0)
{
time+ rt [count];
rt[count]=0; 
flag=1;
}
else if(rt[count]>0)
{
rt[count]-=time_quantum;
time+=time_quantum;
}
if(rt[count] == 0 && flag==1)
{
remain--;
printf("P[%d]\t\t%d\t | \t%d\n", count+1, time-at[count], time-at [count]-bt [count]);
wait_time+=time- at [count]-bt [count];
turnaround_time +-time-at [count];
flag=0;
}
if(count =n-1)
 count=0;

else if(at [count+1]<=time)
 count++;

else
 count=0;
}
printf("\nAverage Waiting Time %.2f\n",wait_time*1.0/n);
printf("Avg Turnaround Time %.2f\n" ,turnaround_time*1.0/n);
break;

case 2:
remain=0;
printf("\n Process Time | Turnaround Time] Waiting Time\n");
rt[9]=9999;
for (time=0; remain!=n; time++)
{
smallest=9;
for (i=0;i<n;i++)
if(at[i]<=time && rt[i]<rt[smallest]&& rt[i]>0)
 smallest=i;
 rt[smallest]--;
if(rt[smallest]==0)
{
    remain++;
    endTime=time+1;
    printf("\nP [%d]\t\t%d\t |\t%d", smallest+1,endTime-at[smallest], endTime-bt [smallest]-at[smallest]);
    printf("\n");
    sum_wait+ endTime-bt [smallest]-at[smallest];
    sum_turnaround+=endTime-at[smallest];
}
}
    printf("\nAverage waiting time = %f\n", sum_wait *1.0/n);
    printf("Average Turnaround time = %f\n", sum_turnaround*1.0/n);
    break;
    default:
        printf("Invalid\n");
}
return 0;
}

8.

 
 #include <stdio.h>
#include <stdlib.h>
int main()
{
    int max[10][10],need[10][10],
    alloc [10][10],av[10],
    c[10],ss[10];
    int p,r,i,j,process,count;
    count=0;
    printf("Enter the no of process:");
    scanf("%d",&p);
    for(i=0;i<p;i++)
    c[i]=0;
    printf("\n\n Enter the no of resouces:");
    scanf("%d",&r);
    printf("\n\n Enter the Max matrix for each process:");
    for(i=0;i<p;i++)
{
    printf("\n For process %d:",i+1);
    for(j=0;j<r;j++)
    scanf("%d",&max[i][j]);
}
    printf("\n\n Enter the allocation for each process:");
    for(i=0;i<p;i++)
    {
        printf("\nFor process %d :",i + 1);
        for(j=0;j<r;j++)
        scanf("%d",& alloc [i][j]);
    }
        printf("\n\n Enter the available resources:");
        for(i=0;i<r;i++)
        scanf("%d",&av[i]);
        for(i=0;i<p;i++)
        for(j=0;j<r;j++)
        need[i][j]=max[i][j]-alloc[i][j];
        do
{
    printf("\n Max matrix :\t allocation matrix:\n");
    for(i=0;i<p;i++)
    {
        for(j=0;j<r;j++)
        printf("%d",max[i][j]);
        printf("\t\t");
        for(j=0;j<r;j++)
        printf("%d",alloc[i][j]);
        printf("\n");
    }
       process=-1;
       for(i=0;i<p;i++)
       {
           if(c[i]==0) // If nott completed
{
    process=i;
    for(j=0;j<r;j++)
    {
        if (av[j]<need[i][j])
       {
           process=-1;
           break;
       }
    }
}
         if(process!=-1)
         break;
       }
       if(process!=-1)
       {
           printf("\n process%d runs to completion!",process+1);
           ss[count]=process+1;
           count++;
           for(j=0;j<r;j++)
           {
               av[j]+=alloc[process][j];
               alloc[process][j]=0;
               max[process][j]=0;
               c[process]=1;
           }
       }
}
            while(count!=p&&process!=-1);
            if (count==p)
            {
                printf("\n The system is in a safe state !!\n");
                printf("safe sequence:<");
                for(i=0;i<p;i++)
                printf("%d",ss[i]);
                printf(">\n");
            }
            else
                printf("\n The system is in an unsafe state!!");
}



9.
#include<stdio.h>
#include<stdlib.h>
void FIFO(char [ ],char [ ],int,int);
void lru(char [ ],char [ ],int,int);
void opt(char [ ],char [ ],int,int);
int main()
{
int ch,YN=1,i,l,f;
char F[10],s[25];
printf("\n\n\tEnter the no of empty frames: "); 
scanf("%d",&f);
printf("\n\n\tEnter the length of the string: ");
scanf("%d",&l);
printf("\n\n\tEnter the string: ");
scanf("%s",s);
for(i=0;i<f;i++)
F[i]=-1;
do
{
printf("\n\n\t*********** MENU ***********");
printf("\n\n\t1:FIFO\n\n\t2:LRU \n\n\t4:EXIT");
printf("\n\n\tEnter your choice: "); 
scanf("%d",&ch);
switch(ch)
{
case 1:
for(i=0;i<f;i++)
{
F[i]=-1;
}
FIFO(s,F,l,f);
break;
case 2:
for(i=0;i<f;i++)
{
F[i]=-1;
}
lru(s,F,l,f);
break;
case 4:
exit(0);
}
printf("\n\n\tDo u want to continue IF YES PRESS 1\n\n\tIF NO PRESS 0 :"); 
scanf("%d",&YN);
}
while(YN==1);return(0);
}
//FIFO
void FIFO(char s[],char F[],int l,int f) {
int i,j=0,k,flag=0,cnt=0;
printf("\n
\tPAGE\t FRAMES\t FAULTS");
for(i=0;i<l;i++) {
for(k=0;k<f;k++)
{
if(F[k]==s[i])
flag=1;
}
if(flag==0)
{
printf("
\n
\t%c
\t",s[i]);
F[j]=s[i];
j++;
for(k=0;k<f;k++) {
printf(" %c",F[k]); }
printf("\tPage-fault%d",cnt);
cnt++;
}
else
{
flag=0;
printf("\n\t%c\t",s[i]);
for(k=0;k<f;k++) {
printf(" %c",F[k]); }
printf("\tNo page-fault");
}
if(j==f)
j=0; }
}
//LRU
void lru(char s[],char F[],int l,int f) {
int i,j=0,k,m,flag=0,cnt=0,top=0;
printf("\n\tPAGE\t FRAMES\t FAULTS"); 
for(i=0;i<l;i++) {
for(k=0;k<f;k++)
{
if(F[k]==s[i]) {
flag=1;
break;
}
}
printf("\n\t%c\t",s[i]);
if(j!=f && flag!=1)
{
F[top]=s[i];
j++;
if(j!=f)
top++;
}
else
{
if(flag!=1) {
for(k=0;k<top;k++) {
F[k]=F[k+1]; }
F[top]=s[i];
}
if(flag==1) {
for(m=k;m<top;m++) {
F[m]=F[m+1]; }
F[top]=s[i];
}
}
for(k=0;k<f;k++)
{
printf(" %c",F[k]); }
if(flag==0)
{
printf("\tPage-fault%d",cnt);
cnt++;
}
else
printf("\tNo page fault");
flag=0;
}
}

    </textarea>